{"ast":null,"code":"/**\n * Utility functions for form validation\n */\n\n/**\n * Validates a form configuration before saving\n * @param {Object} formConfig - The form configuration to validate\n * @returns {Object} Object with validation errors\n */\nexport const validateFormConfig = formConfig => {\n  const {\n    title,\n    description,\n    fields\n  } = formConfig;\n  const errors = {};\n\n  // Validate form title\n  if (!title) {\n    errors.title = \"Form title is required\";\n  }\n\n  // Validate that form has fields\n  if (!fields || fields.length === 0) {\n    errors.fields = \"Form must have at least one field\";\n    return errors;\n  }\n\n  // Validate each field\n  fields.forEach((field, index) => {\n    // Check field question\n    if (!field.question) {\n      errors[`field_${field.id}`] = `Field ${index + 1} must have a question`;\n    }\n\n    // Validate field based on type\n    switch (field.type) {\n      case 'dropdown':\n        if (!field.options || field.options.length === 0) {\n          errors[`field_${field.id}_options`] = `Dropdown field ${index + 1} must have at least one option`;\n        }\n\n        // Validate conditional logic\n        if (field.conditions && field.conditions.length > 0) {\n          field.conditions.forEach((condition, condIndex) => {\n            if (condition.action && !condition.targetId) {\n              errors[`field_${field.id}_condition_${condIndex}`] = `Condition ${condIndex + 1} for field ${index + 1} needs a target question`;\n            }\n          });\n        }\n        break;\n      case 'table':\n        if (!field.columns || field.columns.length === 0) {\n          errors[`field_${field.id}_columns`] = `Table field ${index + 1} must have at least one column`;\n        }\n        break;\n    }\n  });\n  return errors;\n};\n\n/**\n * Verifies that all validation rules are properly configured\n * @param {Array} fields - Array of field configurations\n * @returns {Object} Object with validation errors\n */\nexport const verifyValidationRules = fields => {\n  const errors = {};\n  fields.forEach((field, index) => {\n    if (field.validation) {\n      try {\n        // Check pattern validation\n        if (field.validation.pattern === 'custom') {\n          if (!field.validation.customRule) {\n            errors[`field_${field.id}_validation`] = `Custom validation for field ${index + 1} requires a regex pattern`;\n          } else {\n            // Try to compile the regex\n            try {\n              new RegExp(field.validation.customRule);\n            } catch (e) {\n              errors[`field_${field.id}_validation_regex`] = `Invalid regex pattern for field ${index + 1}: ${e.message}`;\n            }\n          }\n        }\n\n        // Verify error message exists\n        if (!field.validation.errorMessage) {\n          errors[`field_${field.id}_validation_message`] = `Field ${index + 1} should have an error message for validation`;\n        }\n      } catch (e) {\n        errors[`field_${field.id}_validation_error`] = `Error in validation configuration for field ${index + 1}: ${e.message}`;\n      }\n    }\n  });\n  return errors;\n};","map":{"version":3,"names":["validateFormConfig","formConfig","title","description","fields","errors","length","forEach","field","index","question","id","type","options","conditions","condition","condIndex","action","targetId","columns","verifyValidationRules","validation","pattern","customRule","RegExp","e","message","errorMessage"],"sources":["/Users/judyyip/Downloads/Website/Marketing Campaign/frontend/src/utils/formValidation.js"],"sourcesContent":["/**\n * Utility functions for form validation\n */\n\n/**\n * Validates a form configuration before saving\n * @param {Object} formConfig - The form configuration to validate\n * @returns {Object} Object with validation errors\n */\nexport const validateFormConfig = (formConfig) => {\n  const { title, description, fields } = formConfig;\n  const errors = {};\n  \n  // Validate form title\n  if (!title) {\n    errors.title = \"Form title is required\";\n  }\n  \n  // Validate that form has fields\n  if (!fields || fields.length === 0) {\n    errors.fields = \"Form must have at least one field\";\n    return errors;\n  }\n  \n  // Validate each field\n  fields.forEach((field, index) => {\n    // Check field question\n    if (!field.question) {\n      errors[`field_${field.id}`] = `Field ${index + 1} must have a question`;\n    }\n    \n    // Validate field based on type\n    switch (field.type) {\n      case 'dropdown':\n        if (!field.options || field.options.length === 0) {\n          errors[`field_${field.id}_options`] = \n            `Dropdown field ${index + 1} must have at least one option`;\n        }\n        \n        // Validate conditional logic\n        if (field.conditions && field.conditions.length > 0) {\n          field.conditions.forEach((condition, condIndex) => {\n            if (condition.action && !condition.targetId) {\n              errors[`field_${field.id}_condition_${condIndex}`] = \n                `Condition ${condIndex + 1} for field ${index + 1} needs a target question`;\n            }\n          });\n        }\n        break;\n        \n      case 'table':\n        if (!field.columns || field.columns.length === 0) {\n          errors[`field_${field.id}_columns`] = \n            `Table field ${index + 1} must have at least one column`;\n        }\n        break;\n    }\n  });\n  \n  return errors;\n};\n\n/**\n * Verifies that all validation rules are properly configured\n * @param {Array} fields - Array of field configurations\n * @returns {Object} Object with validation errors\n */\nexport const verifyValidationRules = (fields) => {\n  const errors = {};\n  \n  fields.forEach((field, index) => {\n    if (field.validation) {\n      try {\n        // Check pattern validation\n        if (field.validation.pattern === 'custom') {\n          if (!field.validation.customRule) {\n            errors[`field_${field.id}_validation`] = \n              `Custom validation for field ${index + 1} requires a regex pattern`;\n          } else {\n            // Try to compile the regex\n            try {\n              new RegExp(field.validation.customRule);\n            } catch (e) {\n              errors[`field_${field.id}_validation_regex`] = \n                `Invalid regex pattern for field ${index + 1}: ${e.message}`;\n            }\n          }\n        }\n        \n        // Verify error message exists\n        if (!field.validation.errorMessage) {\n          errors[`field_${field.id}_validation_message`] = \n            `Field ${index + 1} should have an error message for validation`;\n        }\n      } catch (e) {\n        errors[`field_${field.id}_validation_error`] = \n          `Error in validation configuration for field ${index + 1}: ${e.message}`;\n      }\n    }\n  });\n  \n  return errors;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}